<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="\u3000参考：深入探索 perf CPU Profiling 实现原理，perfwiki，系统级性能分析工具perf的介绍与使用\nperf 是由 Linux 官方提供的系统性能分析工具 。我们通常说的 perf 实际上包含两部分：\n"><meta name=keywords content="Perf,Linux,Perf events,PMU,LBR"><title>Linux Perf工具</title>
<link rel=canonical href=https://codetang-2417.github.io/p/linux-perf%E5%B7%A5%E5%85%B7/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Linux Perf工具"><meta property='og:description' content="\u3000参考：深入探索 perf CPU Profiling 实现原理，perfwiki，系统级性能分析工具perf的介绍与使用\nperf 是由 Linux 官方提供的系统性能分析工具 。我们通常说的 perf 实际上包含两部分：\n"><meta property='og:url' content='https://codetang-2417.github.io/p/linux-perf%E5%B7%A5%E5%85%B7/'><meta property='og:site_name' content='LingLong'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Performance'><meta property='article:tag' content='Linux'><meta property='article:published_time' content='2024-10-19T10:27:24+08:00'><meta property='article:modified_time' content='2024-10-20T09:33:43+08:00'><meta name=twitter:title content="Linux Perf工具"><meta name=twitter:description content="\u3000参考：深入探索 perf CPU Profiling 实现原理，perfwiki，系统级性能分析工具perf的介绍与使用\nperf 是由 Linux 官方提供的系统性能分析工具 。我们通常说的 perf 实际上包含两部分：\n"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_7866f48be1497b78.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>LingLong</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/codetang-2417/ target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#原理>原理</a></li><li><a href=#使用>使用</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/ style=background-color:#ffbf61;color:#fff>专业知识
</a><a href=/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/ style=background-color:#2a9d8f;color:#fff>编程开发</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/linux-perf%E5%B7%A5%E5%85%B7/>Linux Perf工具</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 19, 2024</time></div></footer></div></header><section class=article-content><p>　　参考：<a class=link href=https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-perf-cpu-profiling-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/ target=_blank rel=noopener>深入探索 perf CPU Profiling 实现原理</a>，<a class=link href=https://perfwiki.github.io/main/ target=_blank rel=noopener>perfwiki</a>，<a class=link href=https://www.cnblogs.com/arnoldlu/p/6241297.html title="发布于 2017-01-04 21:13" target=_blank rel=noopener>系统级性能分析工具perf的介绍与使用</a></p><p>　　<a class=link href=https://perf.wiki.kernel.org/index.php/Main_Page target=_blank rel=noopener>perf</a> 是由 Linux 官方提供的系统性能分析工具 。我们通常说的 perf 实际上包含两部分：</p><ul><li><strong>perf</strong> 命令，用户空间的应用程序，是内核子系统 <strong>perf_events</strong> 的前端工具。</li><li><strong>perf_events</strong> ，Linux 内核中的一个子系统。</li></ul><p>　　<strong>perf_events</strong>是Linux 2.6.31版本引入的内核子系统，可以提供多种来源的事件的性能计数器，供用户空间软件 <strong>perf</strong> 使用，完成性能分析（Performance profiling）。perf 和 perf_events 最初支持硬件计数器（performance monitoring counters，<strong>PMC</strong>），后来扩展到下列的多种事件源的支持。</p><p>　　<strong>perf_events</strong> 4类事件源：</p><ul><li><p><strong>Hardware Events</strong>:：由CPU 性能计数器（performance counters）以及其内部的 Performance Monitoring Unit (PMU)获取，用来统计 Hardware event，例如 cpu-cycles、instructions executed 、cache-misses、branch mispredicted、周期数（the number of cycles）、退役指令（instructions retired）， 缓存未命中（L1 cache misses L1 ）等。这些 event 因每种处理器类型和型号而异。</p><p>注：Last Branch Record（LBR）是Intel CPU中最先引入的一个功能，记录最近执行过的分支指令，可以用来分析分支指令的执行情况，在perf list中，branch相关的功能也被划分到PMU分类，认为LBR的相关数据是通过PMU来获取的。</p></li><li><p><strong>Software Events</strong>: 基于内核计数器的低优先级events， 例如, context-switches，CPU migrations(处理器迁移次数)， minor faults(soft page faults)，major faults(hard page faults)。</p></li><li><p><strong>Tracepoints</strong>:：由内核的 ftrace 实现的跟踪点事件，是散落在内核源代码中的一些 hook，用来调用probe函数。开启后，它们便可以在特定的代码被运行到时被触发，这一特性可以被各种 trace/debug 工具所使用。Perf 就是该特性的用户之一。假如您想知道在应用程序运行期间，内核内存管理模块的行为，便可以利用潜伏在 slab 分配器中的 tracepoint。当内核运行到这些 tracepoint 时，便会通知 perf。仅仅适用于2.6.3以及之后的 linux 内核。除了内核中的tracepoint，还有用户态中的，USDT（User-level statically-defined tracing）。</p></li><li><p><strong>Dynamic Tracing</strong>： probe函数（探针or探测函数），kprobe（kernel probe）内核态探针，用来创建和管理内核代码中的探测点。Uprobes，user-probe，用户态探针，用来对用户态应用程序进行探测点的创建和管理，关于<a class=link href=https://www.kernel.org/doc/html/latest/trace/kprobetrace.html target=_blank rel=noopener>kprobe</a>和<a class=link href=https://www.kernel.org/doc/html/latest/trace/uprobetracer.html target=_blank rel=noopener>uprobe</a>可参考对应的内核文档。</p></li></ul><p>　　下图显示了 perf 命令和 perf_events 的关系，以及 perf_events 支持的事件源。下面的分类和linux perf wiki上的perf_envent分类有些许不同，主要在与tracepoint的定义，下图包含了Static Tracing以及Dynamic Tracing。</p><p>​<img src=/p/linux-perf%E5%B7%A5%E5%85%B7/assets/image-20241019173251-5nhjlei.png width=2616 height=1362 loading=lazy alt=image class=gallery-image data-flex-grow=192 data-flex-basis=460px>​</p><p>　　图片来源：<a class=link href=https://mazhen.tech/p/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-perf-cpu-profiling-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/ target=_blank rel=noopener>深入探索 perf CPU Profiling 实现原理</a></p><p>　　我们可以通过命令<code>perf list</code>​来查看perf支持的事件类型，但<code>perf list</code>​不能完全显示所有支持的事件类型，需要<code>sudo perf list</code>​。</p><p>　　同时还可以显示特定模块支持的perf事件：hw/cache/pmu都是硬件相关的；tracepoint基于内核的ftrace；sw（software）实际上是内核计数器。</p><p>　　下边列出一些<code>sudo perf list</code>​的输出例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>branch</span><span class=o>-</span><span class=n>instructions</span> <span class=n>OR</span> <span class=n>branches</span>                    <span class=p>[</span><span class=n>Hardware</span> <span class=n>event</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=o>-</span><span class=n>switches</span> <span class=n>OR</span> <span class=n>cs</span>                             <span class=p>[</span><span class=n>Software</span> <span class=n>event</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>cpu</span><span class=o>-</span><span class=n>clock</span>                                          <span class=p>[</span><span class=n>Software</span> <span class=n>event</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>L1</span><span class=o>-</span><span class=n>dcache</span><span class=o>-</span><span class=n>load</span><span class=o>-</span><span class=n>misses</span>                              <span class=p>[</span><span class=n>Hardware</span> <span class=n>cache</span> <span class=n>event</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>L1</span><span class=o>-</span><span class=n>dcache</span><span class=o>-</span><span class=n>loads</span>                                    <span class=p>[</span><span class=n>Hardware</span> <span class=n>cache</span> <span class=n>event</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>branch</span><span class=o>-</span><span class=n>instructions</span> <span class=n>OR</span> <span class=n>cpu</span><span class=o>/</span><span class=n>branch</span><span class=o>-</span><span class=n>instructions</span><span class=o>/</span>    <span class=p>[</span><span class=n>Kernel</span> <span class=n>PMU</span> <span class=n>event</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nl>block</span><span class=p>:</span><span class=n>block_bio_backmerge</span>                          <span class=p>[</span><span class=n>Tracepoint</span> <span class=n>event</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>　　下图是很有名的brendan gregg的博客中的分类，他写了很多关于性能分析的书籍和博客。<img src=/p/linux-perf%E5%B7%A5%E5%85%B7/assets/image-20241019114014-vosgddz.png width=1500 height=1050 loading=lazy alt=image class=gallery-image data-flex-grow=142 data-flex-basis=342px>​</p><p>　　图片来源：<a class=link href=https://www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix.html target=_blank rel=noopener>www.brendangregg.com/blog/2015-02-27/linux-profiling-at-netflix&mldr;.</a>、<a class=link href=https://www.brendangregg.com/perf.html target=_blank rel=noopener>www.brendangregg.com/perf.html</a></p><h2 id=原理>原理</h2><p>　　CPU 和其他硬件设备通常提供用于观测性能数据的 PMC。简单来说，<strong>PMC</strong> 就是 CPU 上的<strong>可编程寄存器</strong>，可通过编程对特定硬件事件进行计数。通过 PMC 可以监控和计算 CPU 内部各种事件，比如 CPU 指令的执行效率、CPU caches 的命中率、分支预测的成功率等微结构级别的性能信息。利用这些数据分析性能，可以实现各种性能优化。</p><p>　　perf 命令通过 <a class=link href=https://www.man7.org/linux/man-pages/man2/perf_event_open.2.html target=_blank rel=noopener>perf_event_open(2)</a> 系统调用访问 PMC，配置想要捕获的硬件事件。PMC 可以在两种模式下使用：</p><ul><li>Counting（计数模式），只报告Hardware Event、Software Events、PMU计数等。相关命令perf stat。开销几乎为零。</li><li>Sampling（采样模式），当发生一定数量的事件后，会触发一个中断，以便捕获系统的状态信息。perf将事件数据缓存到一块buffer中，然后异步写入到perf.data文件中。使用perf report等工具进行离线分析。可用于采集代码路径。</li><li>bpf：Kernel 4.4+新增功能，可以提供更多有效filter和输出总结。</li></ul><p>　　下面详细介绍一下 Sampling 模式：</p><p>　　Perf 通过系统调用 sys_perf_event_open 陷入到内核中，内核根据 perf 提供的信息在<a class=link href="https://so.csdn.net/so/search?q=PMU&amp;spm=1001.2101.3001.7020" target=_blank rel=noopener>PMU</a>（Performance Monitoring Unit）上初始化一个硬件性能计数器（PMC: Performance Monitoring Counter）。PMC随着指定硬件事件的发生而自动累加。如果不触发溢出中断，则就是counting模式，例如 perf stat模式。</p><p>　　在PMC 溢出时，PMU触发一个PMI（Performance Monitoring Interrupt）中断。内核在PMI 中断的处理函数中保存PMC的计数值，触发中断时的指令地址，当前时间戳以及当前进程的PID、TID、comm 等信息。我们把这些信息统称为一个采样（sample）。内核会将收集到的sample放入用于跟用户空间通信的Ring Buffer。用户空间里的perf分析程序采用mmap机制从ring buffer中读入采样，并对其解析。</p><p>　　下图从系统调用和数据结构的层面展示了用户空间如何获取PMU信息的流程。还有一张类似的图，是来自阿里的pdf中的，被其他博客转载，或者重绘后使用，其大体内容和下图是一致的。pdf地址：<a class=link href=https://greenteajug.cn/images/%E5%BC%82%E6%9E%84%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84Java%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.pdf target=_blank rel=noopener>类似图</a></p><p>​<img src=/p/linux-perf%E5%B7%A5%E5%85%B7/assets/image-20241019164150-xfko25z.png width=2030 height=930 loading=lazy alt=image class=gallery-image data-flex-grow=218 data-flex-basis=523px>​</p><p>　　图片来源：<a class=link href=https://plantegg.github.io/2021/05/16/Perf_IPC%E4%BB%A5%E5%8F%8ACPU%E5%88%A9%E7%94%A8%E7%8E%87/ target=_blank rel=noopener>plantegg.github.io/2021/05/16/Perf_IPC%E4%BB%A5%E5%8F%8ACPU%E5%8&mldr;</a></p><h2 id=使用>使用</h2><p>　　关于 perf 的详细使用，参考：<a class=link href=https://www.cnblogs.com/arnoldlu/p/6241297.html title="发布于 2017-01-04 21:13" target=_blank rel=noopener>系统级性能分析工具perf的介绍与使用</a></p><p>　　‍</p></section><footer class=article-footer><section class=article-tags><a href=/tags/performance/>Performance</a>
<a href=/tags/linux/>Linux</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Oct 20, 2024 09:33 +0800</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/qemu%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/><div class=article-details><h2 class=article-title>QEMU开发环境搭建</h2></div></a></article><article><a href=/p/qemu-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/><div class=article-details><h2 class=article-title>QEMU 命令参数解析</h2></div></a></article><article><a href=/p/qemu%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97queue/><div class=article-details><h2 class=article-title>QEMU中的队列queue</h2></div></a></article><article><a href=/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E9%9B%86%E5%90%88/><div class=article-details><h2 class=article-title>数据结构知识点集合</h2></div></a></article><article><a href=/p/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/><div class=article-details><h2 class=article-title>时间复杂度</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=codetang-2417/codetang-2417.github.io data-repo-id=R_kgDOMyu4sg data-category=Announcements data-category-id=DIC_kwDOMyu4ss4CiiW6 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark")}})()</script><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 LingLong's Blog</section><section class=powerby>Simple is enough.<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>